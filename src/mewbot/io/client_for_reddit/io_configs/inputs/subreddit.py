"""
Designed to take input from events happening to a watched list of subreddits.
"""


from __future__ import annotations

from typing import List, Optional, Set, Type, Union

import asyncio
import logging
import time

import asyncpraw  # type: ignore
import asyncprawcore  # type: ignore
from mewbot.api.v1 import Input, InputEvent

from ...events import (
    RedditUserBannedFromSubredditInputEvent,
    RedditUserJoinedSubredditInputEvent,
    RedditUserLeftSubredditInputEvent,
    SubRedditCommentCreationInputEvent,
    SubRedditCommentDeletedInputEvent,
    SubRedditCommentEditInputEvent,
    SubRedditCommentRemovedInputEvent,
    SubRedditSubmissionCreationInputEvent,
    SubRedditSubmissionDeletedInputEvent,
    SubRedditSubmissionEditInputEvent,
    SubRedditSubmissionPinnedInputEvent,
    SubRedditSubmissionRemovedInputEvent,
)
from .state import RedditState
from .utils import GenericRedditTools


class RedditSubredditInput(Input, GenericRedditTools):
    """
    Receives input from reddit.

    In particular, watches for events generated by a monitored list of subreddits.
    """

    _loop: Union[None, asyncio.events.AbstractEventLoop]
    _logger: logging.Logger

    praw_reddit: asyncpraw.Reddit

    reddit_state: RedditState

    def __init__(
        self,
        praw_reddit: asyncpraw.Reddit,
        subreddits: List[str],
        override_logger: Optional[logging.Logger] = None,
        reddit_state: Optional[RedditState] = None,
    ) -> None:
        """
        Startup the input, watching a list of subreddits.

        :param praw_reddit: There can only be one asyncpraw instance - so it needs to be
                            passed in
        :param subreddits: The subreddits to monitor
        """

        super().__init__()

        self.praw_reddit = praw_reddit

        self.reddit_state = (
            RedditState(
                target_subreddits=subreddits,
                started_subreddits=set(),
                target_redditors=[],
                started_redditors=set(),
                seen_comments={},
                seen_comment_contents={},
                previous_comment_map={},
                seen_submissions={},
                seen_submission_contents={},
                previous_submission_map={},
            )
            if reddit_state is None
            else reddit_state
        )

        self._logger = (
            logging.getLogger(__name__ + ":" + type(self).__name__)
            if override_logger is None
            else override_logger
        )
        self._logger.info("Monitoring subreddits - %s", self.reddit_state.target_subreddits)

        self._loop = None

    @staticmethod
    def produces_inputs() -> Set[Type[InputEvent]]:
        """
        Depending on the setup, this input could produce any of the below.

        This method produces subreddit specific input events - events which could be best
        gathered by watching a subreddit.
        :return:
        """
        return {
            SubRedditSubmissionCreationInputEvent,
            SubRedditSubmissionEditInputEvent,
            SubRedditSubmissionDeletedInputEvent,
            SubRedditSubmissionRemovedInputEvent,
            SubRedditSubmissionPinnedInputEvent,
            SubRedditCommentCreationInputEvent,
            SubRedditCommentEditInputEvent,
            SubRedditCommentDeletedInputEvent,
            SubRedditCommentRemovedInputEvent,
            RedditUserJoinedSubredditInputEvent,
            RedditUserLeftSubredditInputEvent,
            RedditUserBannedFromSubredditInputEvent,
        }

    @property
    def subreddits(self) -> List[str]:
        """
        List of the subreddits being watched.

        :return:
        """
        return self.reddit_state.target_subreddits

    @subreddits.setter
    def subreddits(self, values: List[str]) -> None:
        """
        Update the subreddits being watched.

        :param values:
        :return:
        """
        self.reddit_state.target_subreddits = values

    @property
    def loop(self) -> asyncio.events.AbstractEventLoop:
        """
        Gets the current event loop.

        :return:
        """
        if self._loop is not None:
            return self._loop
        self._loop = asyncio.get_running_loop()
        return self._loop

    async def run(self, profiles: bool = False) -> None:
        """
        Start polling Reddit.

        :param profiles: Are the subreddits being monitored _actually_ redditor profiles.
                         (Currently this only affects the logging message)
        :return:
        """
        current_user = await self.praw_reddit.user.me()

        if not profiles:
            self._logger.info(
                "About to start watching Reddit - subreddits '%s' will be watched"
                " - logged in as %s",
                self.reddit_state.target_subreddits,
                current_user,
            )
        else:
            self._logger.info(
                "About to start watching Reddit - redditors profiles '%s' will be watched"
                " - logged in as %s",
                self.reddit_state.target_subreddits,
                current_user,
            )

        for subreddit in self.reddit_state.target_subreddits:
            self.loop.create_task(self.monitor_subreddit_comments(subreddit))
            self.loop.create_task(self.monitor_subreddit_submissions(subreddit))

            self.reddit_state.started_subreddits.add(subreddit)

    # ----------------
    # MONITOR COMMENTS

    async def monitor_subreddit_comments(self, target_subreddit: str) -> None:
        """
        Monitor a subreddit for comments and put them on the wire.

        :param target_subreddit:
        :return:
        """
        self._logger.info(
            "Monitoring subreddit '%s' for comments",
            target_subreddit,
        )

        multireddit = await self.praw_reddit.subreddit(target_subreddit, fetch=True)

        # async-praw offers a comment stream - so processing comments as they come off the stream
        async for comment in multireddit.stream.comments():
            print("-------------")
            print(self.render_comment(comment))
            print("-------------")
            await self.subreddit_comment_to_event(
                subreddit=target_subreddit, reddit_comment=comment
            )

    def is_comment_top_level(self, reddit_comment: asyncpraw.reddit.Comment) -> bool:
        """
        Return True if a comment is top level and False otherwise.

        :param reddit_comment:
        :return:
        """
        # Parse the parent_id to determine the type of comment this is
        comment_parent_id = reddit_comment.parent_id

        # Comment is definitely attached to another comment - so note it as such in the event
        if comment_parent_id.startswith("t1_"):
            top_level = False
        # Comment has the submission id of a parent as a post - so it's definitely top level
        elif comment_parent_id.startswith("t3_"):
            top_level = True
        else:
            # This should never happen
            self._logger.info(
                "Unexpected case when trying to comment_parent_id - %s", comment_parent_id
            )
            top_level = False

        return top_level

    async def subreddit_comment_to_event(
        self, subreddit: str, reddit_comment: asyncpraw.reddit.Comment
    ) -> None:
        """
        Takes a comment posted in a subreddit and puts it on the wire as an event.

        :param subreddit: The declared subreddit we are polling from
                          (There may be multi-subreddit or composite subreddit shennanigans
                          going on - so just declaring the subreddit mewbot _thinks_ its
                          drawing from)
        :param reddit_comment:
        :return:
        """
        top_level = self.is_comment_top_level(reddit_comment)

        # "Detect" removed or deleted comments - a poor method, but the best that can be done atm
        # Note - there may be issues where this does not work for non-english language subreddits
        if reddit_comment.body == r"[removed]":
            # Per notes in reddit-dev-notes.md
            # Not sure if removed events are being broadcast by the API
            if reddit_comment.author == r"[deleted]":
                await self.process_subreddit_removed_comment_on_submission(
                    subreddit, reddit_comment, top_level=top_level
                )

                return

        if reddit_comment.body == r"[deleted]":
            await self.process_subreddit_deleted_comment_on_submission(
                subreddit, reddit_comment, top_level
            )

            return

        # Not sure if editing a comment produces a separate event in this result
        # Or if it just happens to change the status of the observed event to edited
        # Given this is intended to be the backend for a _display_ system - it probably
        # DOES NOT produce a separate event

        # Note - depending on the cache size events will start falling out of it
        # So it's fairly certain that we won't be able to provide the pre-edit content

        # If a comment has been edited, then it needs to go on the wire as an edited event
        if reddit_comment.edited:
            await self.process_subreddit_edited_comment_on_submission(
                subreddit, reddit_comment, top_level
            )

            return

        # If a message is not declared as edited, deleted or removed, just put it on the wire
        await self.process_subreddit_created_comment_on_submission(
            subreddit, reddit_comment, top_level
        )

    async def process_subreddit_created_comment_on_submission(
        self, subreddit: str, reddit_comment: asyncpraw.reddit.Comment, top_level: bool
    ) -> None:
        """
        A comment has been created in a monitored subreddit/profile - on a submission.

        Subreddit first.
        :param subreddit:
        :param reddit_comment:
        :param top_level:
        :return:
        """
        # Hash work here?
        self.reddit_state.seen_comment_contents[reddit_comment.id] = reddit_comment

        comment_creation_input_event = SubRedditCommentCreationInputEvent(
            comment=reddit_comment,
            subreddit=subreddit,
            parent_id=reddit_comment.parent_id,
            author_str=str(reddit_comment.author),
            top_level=top_level,
            creation_timestamp=reddit_comment.created_utc,
        )

        await self.send(comment_creation_input_event)

    async def process_subreddit_edited_comment_on_submission(
        self, subreddit: str, reddit_comment: asyncpraw.reddit.Comment, top_level: bool
    ) -> None:
        """
        A comment has been edited in a monitored subreddit.

        :param subreddit:
        :param reddit_comment:
        :param top_level:
        :return:
        """
        message_id = reddit_comment.id

        # Check if we have an existing old message to assign to this message
        message_hash = self.hash_comment(reddit_comment)
        if message_hash in self.reddit_state.previous_comment_map:
            old_message = self.reddit_state.previous_comment_map[message_hash]
        else:
            old_message = self.reddit_state.seen_comment_contents.get(message_id, None)

        comment_edit_input_event = SubRedditCommentEditInputEvent(
            comment=reddit_comment,
            subreddit=subreddit,
            parent_id=reddit_comment.parent_id,
            author_str=str(reddit_comment.author),
            top_level=top_level,
            # If we have it in our internal cache
            pre_edit_message=old_message,
            # This may be the best we can do - as the message doesn't seem to have a "last edited"
            # or similar field
            edit_timestamp=str(time.time()),
        )
        await self.send(comment_edit_input_event)

        self.reddit_state.previous_comment_map[message_hash] = old_message
        # Store the current state of the message - in case it's edited again
        self.reddit_state.seen_comment_contents[message_id] = reddit_comment

    async def process_subreddit_deleted_comment_on_submission(
        self, subreddit: str, reddit_comment: asyncpraw.reddit.Comment, top_level: bool
    ) -> None:
        """
        A comment has been deleted from a submission (on from somewhere in its comment forest).

        :param subreddit:
        :param reddit_comment:
        :param top_level:
        :return:
        """
        # Check to see if we have an old message
        comment_hash = self.hash_comment(reddit_comment)
        old_reddit_message = self.reddit_state.previous_comment_map.get(comment_hash, None)

        # If we don't, try in the seen comments
        if old_reddit_message is None:
            old_reddit_message = self.reddit_state.seen_comment_contents[subreddit].get(
                reddit_comment.id, None
            )

        # Update the cache - if a message has been removed it should never change again
        self.reddit_state.previous_comment_map[comment_hash] = None
        # Indicate that the comment is gone by setting the contents to None
        self.reddit_state.seen_comment_contents[subreddit][reddit_comment.id] = None

        deleted_message_event = SubRedditCommentDeletedInputEvent(
            comment=reddit_comment,
            subreddit=reddit_comment.subreddit,
            author_str=old_reddit_message.author.id,
            top_level=top_level,
            del_timestamp=str(time.time()),
            parent_id=reddit_comment.parent_id,
        )
        await self.send(deleted_message_event)

    async def process_subreddit_removed_comment_on_submission(
        self, subreddit: str, reddit_comment: asyncpraw.reddit.Comment, top_level: bool
    ) -> None:
        """
        A comment has been removed from a submission (on from somewhere in its comment forest).

        Subreddit first.
        :param subreddit:
        :param reddit_comment:
        :param top_level:
        :return:
        """

        # Check to see if we have an old message
        comment_hash = self.hash_comment(reddit_comment)
        old_reddit_message = self.reddit_state.previous_comment_map.get(comment_hash, None)

        # If we don't, try in the seen comments
        if old_reddit_message is None:
            old_reddit_message = self.reddit_state.seen_comment_contents[subreddit].get(
                reddit_comment.id, None
            )

        # Update the cache - if a message has been removed it should never change again
        self.reddit_state.previous_comment_map[comment_hash] = None

        # Indicate that the comment is gone by setting the contents to None
        self.reddit_state.seen_comment_contents[subreddit][reddit_comment.id] = None

        # Without the old message there is no good way to know who the author was
        old_author_str = (
            "" if old_reddit_message is None else str(old_reddit_message.author.id)
        )

        removed_message_event = SubRedditCommentRemovedInputEvent(
            comment=reddit_comment,
            subreddit=reddit_comment.subreddit,
            author_str=old_author_str,
            top_level=top_level,
            remove_timestamp=str(time.time()),
            parent_id=reddit_comment.parent_id,
        )

        await self.send(removed_message_event)

    # -------------------
    # MONITOR SUBMISSIONS

    async def monitor_subreddit_submissions(self, target_subreddit: str) -> None:
        """
        Monitor a subreddit for submissions and put them on the wire.

        :param target_subreddit:
        :return:
        """
        self._logger.info(
            "Monitoring subreddit '%s' for submissions",
            target_subreddit,
        )

        try:
            multireddit = await self.praw_reddit.subreddit(target_subreddit, fetch=True)
        except asyncprawcore.exceptions.NotFound:
            self._logger.info(
                "Subreddit could not be found - hence polling cannot start - '%s'",
                target_subreddit,
            )
            return

        # async-praw offers a comment stream - so processing comments as they come off the stream
        async for submission in multireddit.stream.submissions():
            print("-------------")
            print(self.render_submission(submission))
            print("-------------")
            await self.subreddit_submission_to_event(
                subreddit=target_subreddit, reddit_submission=submission
            )

    @staticmethod
    def hash_submission(submission_comment: asyncpraw.reddit.Submission) -> str:
        """
        Take a comment and return a hash for it.

        This is pretty simple - just a str of a tuple of the comment_id and contents
        :param submission_comment:
        :return:
        """
        return str(
            (submission_comment.id, submission_comment.selftext, submission_comment.author)
        )

    async def subreddit_submission_to_event(
        self, subreddit: str, reddit_submission: asyncpraw.reddit.Submission
    ) -> None:
        """
        Takes a reddit comment and puts it on the wire as an event.

        :param subreddit: The declared subreddit we are polling from
                          (There may be multi-subreddit or composite subreddit shennanigans
                          going on - so just declaring the subreddit mewbot _thinks_ its
                          drawing from)
        :param reddit_submission:
        :return:
        """
        # "Detect" removed or deleted comments - a poor method, but the best that can be done atm
        # Note - there may be issues where this does not work for non-english language subreddits
        if reddit_submission.selftext == r"[removed]":
            # Per notes in reddit-dev-notes.md
            # Not sure if removed events are being broadcast by the API
            if reddit_submission.author == r"[deleted]":
                await self.process_subreddit_removed_submission(subreddit, reddit_submission)

                return

        if reddit_submission.selftext == r"[deleted]":
            await self.process_subreddit_deleted_submission(subreddit, reddit_submission)

            return

        # Not sure if editing a submission produces a separate event in this stream
        # Or if it just happens to change the status of the observed event to edited
        # Given this is intended to be the backend for a _display_ system - it probably
        # DOES NOT produce a separate event

        # Note - depending on the cache size events will start falling out of it
        # So it's fairly certain that we won't be able to provide the pre-edit content

        # If a submission has been edited, then it needs to go on the wire as an edited event
        if reddit_submission.edited:
            await self.process_subreddit_edited_submission(subreddit, reddit_submission)

            return

        # If a message is not declared as edited, deleted or removed, just put it on the wire
        await self.process_subreddit_created_submission(subreddit, reddit_submission)

    async def process_subreddit_created_submission(
        self, subreddit: str, reddit_submission: asyncpraw.reddit.Submission
    ) -> None:
        """
        A submission has been created in a monitored subreddit.

        :param subreddit:
        :param reddit_submission:
        :return:
        """
        submission_creation_input_event = SubRedditSubmissionCreationInputEvent(
            subreddit=subreddit,
            submission_id=reddit_submission.id,
            submission=reddit_submission,
            author_str=str(reddit_submission.author),
            creation_timestamp=reddit_submission.created_utc,
            submission_content=reddit_submission.selftext,
            submission_image=reddit_submission.url,
            submission_title=reddit_submission.title,
        )

        await self.send(submission_creation_input_event)

    async def process_subreddit_edited_submission(
        self, subreddit: str, reddit_submission: asyncpraw.reddit.Submission
    ) -> None:
        """
        A submission has been edited in a monitored subreddit.

        :param subreddit:
        :param reddit_submission:
        :return:
        """

        message_id = reddit_submission.id

        # Check if we have an existing old message to assign to this message
        message_hash = self.hash_submission(reddit_submission)
        if message_hash in self.reddit_state.previous_submission_map:
            old_message = self.reddit_state.previous_submission_map[message_hash]
        else:
            old_message = self.reddit_state.seen_submission_contents.get(message_id, None)

        submission_edit_input_event = SubRedditSubmissionEditInputEvent(
            submission=reddit_submission,
            author_str=str(reddit_submission.author),
            submission_image=None,
            submission_title=reddit_submission.title,
            # If we have it in our internal cache
            pre_edit_submission=old_message,
            # This may be the best we can do - as the message doesn't seem to have a "last edited"
            # or similar field
            edit_timestamp=str(time.time()),
            subreddit=subreddit,
            submission_content=reddit_submission.selftext,
            submission_id=reddit_submission.id,
        )
        await self.send(submission_edit_input_event)

        self.reddit_state.previous_submission_map[message_hash] = old_message

        # Store the current state of the message - in case it's edited again
        self.reddit_state.seen_submission_contents[message_id] = reddit_submission

    async def process_subreddit_deleted_submission(
        self, subreddit: str, reddit_submission: asyncpraw.reddit.Submission
    ) -> None:
        """
        A submission has been deleted in a monitored subreddit.

        :param subreddit:
        :param reddit_submission:
        :return:
        """

        # Check to see if we have an old message
        submission_hash = self.hash_submission(reddit_submission)
        old_reddit_submission = self.reddit_state.previous_submission_map.get(
            submission_hash, None
        )

        # If we don't, try in the seen submissions
        if old_reddit_submission is None:
            old_reddit_submission = self.reddit_state.seen_submission_contents[subreddit].get(
                reddit_submission.id, None
            )

        # Update the cache - if a message has been removed it should never change again
        self.reddit_state.previous_submission_map[submission_hash] = None
        # Indicate that the submission is gone by setting the contents to None
        self.reddit_state.seen_submission_contents[subreddit][reddit_submission.id] = None

        deleted_message_event = SubRedditSubmissionDeletedInputEvent(
            submission=reddit_submission,
            subreddit=reddit_submission.subreddit,
            submission_title=reddit_submission.title,
            author_str=old_reddit_submission.author.id,
            del_timestamp=str(time.time()),
            submission_content=reddit_submission.selftext,
            submission_id=reddit_submission.id,
            submission_image=None,
        )
        await self.send(deleted_message_event)

    async def process_subreddit_removed_submission(
        self, subreddit: str, reddit_submission: asyncpraw.reddit.Submission
    ) -> None:
        """
        A submission has been deleted in a monitored subreddit.

        :param subreddit:
        :param reddit_submission:
        :return:
        """

        # Check to see if we have an old message
        submission_hash = self.hash_submission(reddit_submission)
        old_reddit_submission = self.reddit_state.previous_submission_map.get(
            submission_hash, None
        )

        # If we don't, try in the seen submissions
        if old_reddit_submission is None:
            old_reddit_submission = self.reddit_state.seen_submission_contents[subreddit].get(
                reddit_submission.id, None
            )

        # Update the cache - if a message has been removed it should never change again
        self.reddit_state.previous_submission_map[submission_hash] = None
        # Indicate that the submission is gone by setting the contents to None
        self.reddit_state.seen_submission_contents[subreddit][reddit_submission.id] = None

        # Without the old message there is no good way to know who the author was
        old_author_str = (
            "" if old_reddit_submission is None else str(old_reddit_submission.author.id)
        )

        removed_message_event = SubRedditSubmissionRemovedInputEvent(
            submission_id=reddit_submission.id,
            submission_title=reddit_submission.title,
            submission=reddit_submission,
            subreddit=reddit_submission.subreddit,
            author_str=old_author_str,
            remove_timestamp=str(time.time()),
            submission_content=reddit_submission.selftext,
            submission_image=reddit_submission.url,
        )

        await self.send(removed_message_event)

    # -------------------

    async def send(self, reddit_input_event: InputEvent) -> None:
        """
        Put a created InputEvent on the wire.

        :param reddit_input_event:
        :return:
        """
        if self.queue is not None:
            await self.queue.put(reddit_input_event)
